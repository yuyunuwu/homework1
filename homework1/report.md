---
title: homework1

---

# homework1
51115140
## 作業一

### 解題說明
ackermann函數：

遞迴規則如下：

若 m == 0 回傳 n + 1

若 n == 0 回傳 A(m-1, 1)

否則回傳 A(m-1, A(m, n-1))

#### 解題策略

每個元素可選或不選 用遞迴列出所有組合（2^n 個）用 n[] 建立暫存陣列儲存結果

### 效能分析

時間複雜度:O 增長極快 >O(2^n)

空間複雜度:O 因堆疊 空間可能快速耗盡

### 效能量測

| 變數 | 執行時間(ms) |
|----------|--------------|
| A(1, 2) | 極快 | 
| A(3, 3)  | 約幾百ms | 
| A(4, 1)  | 極慢 不然就爆炸 | 


#### 測試案例

A(0, 5) → 6

A(2, 3) → 9

A(3, 2) → 29

#### 結論

函數適合用來測試遞迴效能，但不適合實際應用

### 心得

不能應用 可以拿來測試 或列出來給你看

## 作業二


#### 解題策略

每個元素可選或不選 用遞迴列出所有組合（2^n 個）用 n[] 建立暫存陣列儲存結果

### 效能分析

時間複雜度為 O(2^n)因為每個元素都可能出現在或不出現在子集合中(選或不選)


### 效能量測

| 輸入字串長度 | 子集合數量 | 執行時間 |
|----------|--------------|----------|
| 3  | 8 |   極快    | 
| 4  | 16 |   極快     |
| 10  | 1024 |  較慢    | 

分析：時間隨 $ 2^n $ 增長，符合 $ O(2^n) $


#### 測試案例

輸入 "ab" -> 輸出 "", "a", "b", "ab"

輸入 "abc" -> 共 8 個子集合

輸入 "" -> 僅一個空集合 ""


#### 結論

雖然比較不會爆掉 但還是不能用太大的字串

### 心得討論

動態記憶體配置好像比vector好用?
